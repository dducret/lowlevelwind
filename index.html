<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Low Level Wind</title>
    <script src="https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/deck.gl@9.1.4/dist/dist.dev.js"></script>
    <script src="https://unpkg.com/weatherlayers-gl@2025.5.0/dist/weatherlayers-client.umd.min.js"></script>
    <script src="https://unpkg.com/weatherlayers-gl@2025.5.0/dist/weatherlayers-deck.umd.min.js"></script>
    <script src="https://unpkg.com/pmtiles@3.2.0/dist/pmtiles.js"></script>
    <script src="https://unpkg.com/geotiff@2.1.3/dist-browser/geotiff.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }

        .center-marker {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        .marker-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 0, 0, 1);
            border-radius: 50%;
            position: relative;
        }

        .marker-label {
            position: absolute;
            bottom: 13px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            color: black;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            user-select: none;
            font-family: sans-serif;
            white-space: nowrap;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translate(-50%, 0);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.7);
            padding: 16px;
            border-radius: 12px;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        @media (min-width: 600px) {
            #controls {
                flex-direction: row;
                gap: 20px;
            }
        }

        #controls div {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #controls button {
            font-size: 18px;
            padding: 8px 12px;
            border: none;
            background: #007bffc4;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #controls button:hover {
            background: #0056b3;
        }

        #controls select {
            font-size: 16px;
            padding: 12px 10px;
            border-radius: 6px;
            border: 1px solid #ccc;
            width: 180px;
            box-sizing: border-box;
        }
    </style>
</head>

<body onload="javascript:setTimeout(function(){ location.reload(); },10800000);">
    <div id="map">
    </div>
    <div id="controls">
        <div>
            <select id="timeSelect" onchange="onChange()"></select>
            <button onclick="prev('time')">◀</button>
            <button onclick="next('time')">▶</button>
        </div>
        <div>
            <select id="altitudeSelect" onchange="onChange()"></select>
            <button onclick="prev('altitude')">◀</button>
            <button onclick="next('altitude')">▶</button>
        </div>
    </div>
    <div class="center-marker">
        <div id="centerLabel" class="marker-label">Loading…<br>Loading...</div>
        <div class="marker-dot"></div>
    </div>
    <script type="module">
        window.addEventListener('DOMContentLoaded', async () => {
            const protocol = new pmtiles.Protocol();
            maplibregl.addProtocol('pmtiles', protocol.tile);
            const map = window.map = new maplibregl.Map({
                container: 'map',
                style: 'style-white.json',
                center: [8.2, 46.8],
                zoom: 8,
                hash: 'map',
                attributionControl: false,
            });

            map.on('load', function () {
                map.addSource('dem', {
                    'type': 'raster-dem',
                    'tiles': ['https://elevation-tiles-prod.s3.amazonaws.com/terrarium/{z}/{x}/{y}.png'],
                    'tileSize': 256,
                    'minzoom': 0,
                    'maxzoom': 13,
                    'encoding': "terrarium",
                });
                map.addLayer({
                    id: "hills",
                    type: "hillshade",
                    source: "dem",
                    paint: {
                        'hillshade-method': 'igor',
                        'hillshade-illumination-altitude': 45,
                        'hillshade-illumination-direction': 315,
                        'hillshade-shadow-color': 'rgba(0, 0, 0, 0.3)',
                        'hillshade-highlight-color': 'rgba(255, 255, 255, 0.3)',
                        'hillshade-accent-color': 'rgba(0, 0, 0, 0.3)',
                    }
                }, 'places_locality')

            });

            map.addControl(new maplibregl.AttributionControl({
                compact: true,
                customAttribution: '<a href="https://sma.ch">MeteoSwiss ICON CH1</a> | <a href="https://weatherlayers.com/">WeatherLayers</a> | <a href="https://github.com/dducret/lowlevelwind">Source Code</a>'
            }), 'top-left');

            await new Promise(resolve => map.once('style.load', resolve));

            WeatherLayers.setLibrary('geotiff', GeoTIFF);

            const deckLayer = new deck.MapboxOverlay({
                interleaved: true,
                layers: [],
            });
            map.addControl(deckLayer);

            function waitForDeck(getDeck) {
                return new Promise(resolve => {
                    function wait() {
                        const deck = getDeck();
                        if (deck && deck.getCanvas()) {
                            resolve(deck);
                        } else {
                            setTimeout(wait, 100);
                        }
                    }
                    wait();
                });
            }
            const deckgl = window.deckgl = await waitForDeck(() => deckLayer._deck);

            let currentImageUrl = '';
            let currentHflImageUrl = '';
            let image = undefined;
            let hflImage = undefined;

            const imageUnscale = [-128, 127];
            const bounds = [5.379263587935693, 45.497280246347316, 11.0242973, 48.1058362];

            const updateMarker = () => {
                if (!image || !hflImage) {
                    document.getElementById('centerLabel').innerHTML = 'NaN km/h<br>NaN m AMSL';
                    return;
                }
                const imageProperties = {
                    image,
                    image2: null,
                    imageSmoothing: 0,
                    imageInterpolation: WeatherLayers.ImageInterpolation.CUBIC,
                    imageWeight: 0,
                    imageType: WeatherLayers.ImageType.VECTOR,
                    imageUnscale,
                }
                const hflImageProperties = {
                    'image': hflImage,
                    image2: null,
                    imageSmoothing: 0,
                    imageInterpolation: WeatherLayers.ImageInterpolation.CUBIC,
                    imageWeight: 0,
                    imageType: WeatherLayers.ImageType.SCALAR,
                }
                const bbox = [-5, 45, 12, 49];
                const center = map.getCenter();
                const topLeft = map.unproject([0, 0]);
                const points = [[center.lng, (center.lat + topLeft.lat) / 2]]
                const collection = WeatherLayers.getRasterPoints(imageProperties, bounds, points);
                const properties = collection['features'][0]['properties'];
                const hflCollection = WeatherLayers.getRasterPoints(hflImageProperties, bounds, points);
                const elevation = hflCollection['features'][0]['properties']['value'];
                document.getElementById('centerLabel').innerHTML = `${properties.value.toFixed(1)} km/h<br>${elevation.toFixed(0)} m AMSL`;
            }

            const updateLayers = async (model, member, altitude, time) => {
                try {
                    const newImage = await WeatherLayers.loadTextureData(`data-copy/${model}-${member}-${altitude}-${time}-wind.png`, false);
                    image = newImage;
                    const newHflImage = await WeatherLayers.loadTextureData(`data-copy/hfl-${altitude}.tif`, false);
                    hflImage = newHflImage;
                }
                catch (err) {
                    console.log('error', err)
                    image = undefined;
                    deckLayer.setProps({ layers: [] });
                    updateMarker();
                    return;
                }

                const paletteSMA = [
                    [1.852 * 0, [255, 255, 255]],
                    [1.852 * 4, [239, 244, 209]],
                    [1.852 * 6, [232, 244, 158]],
                    [1.852 * 10, [170, 206, 99]],
                    [1.852 * 14, [170, 206, 99]],
                    [1.852 * 18, [226, 237, 22]],
                    [1.852 * 22, [255, 237, 0]],
                    [1.852 * 26, [255, 237, 130]],
                    [1.852 * 30, [244, 209, 127]],
                    [1.852 * 35, [237, 165, 73]],
                    [1.852 * 40, [229, 140, 61]],
                    [1.852 * 45, [219, 124, 61]],
                ];
                const beforeId = 'water-lake';
                deckLayer.setProps({
                    layers: [
                        new WeatherLayers.RasterLayer({
                            id: 'raster',
                            image,
                            image2: null,
                            imageSmoothing: 0,
                            imageInterpolation: WeatherLayers.ImageInterpolation.CUBIC,
                            imageWeight: 0,
                            imageType: WeatherLayers.ImageType.VECTOR,
                            imageUnscale,
                            imageMinValue: null,
                            imageMaxValue: null,
                            bounds,
                            visible: true,
                            palette: paletteSMA,
                            opacity: 1.0,
                            pickable: true,
                            extensions: [new deck.ClipExtension()],
                            clipBounds: [-5, 45, 12, 49],
                            beforeId,
                        }),
                        new WeatherLayers.ParticleLayer({
                            id: 'particle',
                            image,
                            image2: null,
                            imageSmoothing: 0,
                            imageInterpolation: WeatherLayers.ImageInterpolation.CUBIC,
                            imageWeight: 0,
                            imageType: WeatherLayers.ImageType.VECTOR,
                            imageUnscale,
                            bounds,
                            visible: true,
                            numParticles: Math.round(100 * window.innerWidth * window.innerHeight / 300000),
                            maxAge: 15,
                            speedFactor: 8,
                            width: 2.5,
                            color: [255, 255, 255],
                            palette: [
                                [0, [0, 0, 0]],
                                [15, [255, 255, 255]],
                            ],
                            opacity: 1.0,
                            animate: true,
                            extensions: [new deck.ClipExtension()],
                            clipBounds: [-5, 45, 12, 49],
                            getPolygonOffset: () => [0, -1000],
                            beforeId,
                        }),
                    ],
                });

                updateMarker();
            };

            async function initControls() {
                const models = ['CH1', 'CH2'];
                const altitudeSteps = [];
                for (let z = 35; z <= 80; ++z) { /* # According to MeteoSwiss, the published range is 1–80. Since Z35 is above 5,500 metres, no higher range is required */
                    altitudeSteps.push(`Z${z}`)
                }
                const members = ['CTRL', ...Array.from({ length: 11 }, (_, i) => `EPS${i}`)];
                const defaultAltitudeLevel = 'Z80';

                async function loadAltitudeLabels() {
                    try {
                        const response = await fetch('altitude_levels.json');
                        if (!response.ok) {
                            throw new Error(`Unexpected response ${response.status}`);
                        }
                        const payload = await response.json();
                        if (Array.isArray(payload)) {
                            return payload.reduce((acc, entry) => {
                                if (!entry) {
                                    return acc;
                                }
                                const code = entry.code || entry.id || entry.level || entry.name;
                                const value = entry.meters ?? entry.altitude ?? entry.height ?? entry.value ?? entry.label;
                                if (code) {
                                    acc[String(code)] = value;
                                }
                                return acc;
                            }, {});
                        }
                        if (payload && typeof payload === 'object') {
                            if (payload.levels && typeof payload.levels === 'object') {
                                return payload.levels;
                            }
                            return payload;
                        }
                    } catch (error) {
                        console.warn('Unable to load altitude label mapping, falling back to model level codes.', error);
                    }
                    return {};
                }

                const altitudeLabelPromise = loadAltitudeLabels();
                const lastRunResponse = await fetch('data-copy/last_run.json'); // Update this path
                if (!lastRunResponse.ok) {
                    throw new Error(`Unexpected response ${lastRunResponse.status} while loading available times.`);
                }
                const altitudeLabelMap = await altitudeLabelPromise;
                const data = await lastRunResponse.json();
                const lastRunTimestamp = data.last_run;
                const times = [];
                for (let i = 0; i <= 33; i++) {
                    times.push(lastRunTimestamp + i * 3600);
                }

                const selectIds = {
                    time: 'timeSelect',
                    altitude: 'altitudeSelect',
                };
                
                function formatCustomTime(unixSeconds) {
                    const date = new Date(unixSeconds * 1000);
                    const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const day = weekdays[date.getDay()];
                    const hours = date.getHours(); // local time
                    return `${day} ${hours.toString().padStart(2, '0')}:00`;
                }
                
                function formatAltitudeLabel(code) {
                    const raw = altitudeLabelMap?.[code];
                    if (raw === undefined || raw === null) {
                        return code;
                    }
                    if (typeof raw === 'number') {
                        return `${raw} m AGL`;
                    }
                    const trimmed = String(raw).trim();
                    if (trimmed === '') {
                        return code;
                    }
                    const numeric = Number(trimmed);
                    if (!Number.isNaN(numeric)) {
                        return `${numeric} m AGL`;
                    }
                    return /m\b/i.test(trimmed) ? trimmed : `${trimmed} m AGL`;
                }

                function populateSelect(id, values, options = {}) {
                    const sel = document.getElementById(id);
                    sel.textContent = '';
                    const { formatter, defaultValue } = options;
                    values.forEach(value => {
                        const opt = document.createElement('option');
                        opt.value = value;
                        const label = formatter ? formatter(value) : value;
                        opt.textContent = label;
                        if (id === 'altitudeSelect' && label !== value) {
                            opt.title = `${value} (${label})`;
                        }
                        sel.appendChild(opt);
                    });
                    if (defaultValue !== undefined) {
                        const matching = Array.from(sel.options).find(option => option.value === defaultValue);
                        if (matching) {
                            matching.selected = true;
                        }
                    }
                }

                populateSelect(selectIds.time, times, { formatter: formatCustomTime });
                populateSelect(selectIds.altitude, altitudeSteps, { formatter: formatAltitudeLabel, defaultValue: defaultAltitudeLevel });

                async function onChange() {
                    const model = 'CH1'; 
                    const time = document.getElementById('timeSelect').value;
                    const altitude = document.getElementById('altitudeSelect').value;
                    const member = 'CTRL'; 
                    await updateLayers(model, member, altitude, time);
                }

                function prev(type) {
                    const sel = document.getElementById(selectIds[type]);
                    if (sel.selectedIndex > 0) {
                        sel.selectedIndex -= 1;
                    }
                    onChange();
                }

                function next(type) {
                    const sel = document.getElementById(selectIds[type]);
                    if (sel.selectedIndex < sel.options.length - 1) {
                        sel.selectedIndex += 1;
                    }
                    onChange();
                }

                window.onChange = onChange;
                window.prev = prev;
                window.next = next;

                map.on('move', updateMarker);
                map.dragRotate.disable();
                map.touchZoomRotate.disableRotation();
                map.keyboard.disableRotation();
                map.setPitch(0);
                map.setBearing(0);
                map.resize();

                onChange();
            }

            initControls().catch(error => {
                console.error('Failed to initialise controls', error);
            });

        });


    </script>
</body>

</html>

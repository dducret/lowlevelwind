<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Low Level Wind</title>
    <script src="https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@5.5.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/deck.gl@9.1.4/dist/dist.dev.js"></script>
    <script src="https://unpkg.com/weatherlayers-gl@2025.5.0/dist/weatherlayers-client.umd.min.js"></script>
    <script src="https://unpkg.com/weatherlayers-gl@2025.5.0/dist/weatherlayers-deck.umd.min.js"></script>
    <script src="https://unpkg.com/pmtiles@3.2.0/dist/pmtiles.js"></script>
    <script src="https://unpkg.com/geotiff@2.1.3/dist-browser/geotiff.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
            width: 100%;
        }

        #loadingOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.85);
            z-index: 2000;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #loadingOverlay.is-hidden {
            opacity: 0;
            visibility: hidden;
        }

        #loadingOverlay .hourglass {
            font-size: 64px;
            animation: hourglass-spin 1.2s linear infinite;
        }

        @keyframes hourglass-spin {
            0% {
                transform: rotate(0deg);
            }
            50% {
                transform: rotate(180deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .center-marker {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        .marker-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 0, 0, 1);
            border-radius: 50%;
            position: relative;
        }

        .marker-label {
            position: absolute;
            bottom: 13px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            color: black;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            user-select: none;
            font-family: sans-serif;
            white-space: nowrap;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translate(-50%, 0);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.7);
            padding: 16px;
            border-radius: 12px;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(6px);
        }

        @media (min-width: 600px) {
            #controls {
                flex-direction: row;
                gap: 20px;
            }
        }

        #controls div {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #controls button {
            font-size: 18px;
            padding: 8px 12px;
            border: none;
            background: #007bffc4;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #controls button:hover {
            background: #0056b3;
        }

        #controls button:focus-visible {
            outline: 2px solid #0056b3;
            outline-offset: 2px;
        }

        #controls button:disabled {
            background: #7daeff;
            cursor: not-allowed;
            opacity: 0.75;
        }

        #controls button:disabled:hover {
            background: #7daeff;
        }

        #controls select {
            font-size: 16px;
            padding: 12px 10px;
            border-radius: 6px;
            border: 1px solid #ccc;
            width: 180px;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.95);
        }

        #controls select:focus-visible {
            outline: 2px solid #0056b3;
            outline-offset: 2px;
        }
    </style>
</head>

<body>
    <div id="loadingOverlay" role="status" aria-live="polite">
        <div class="hourglass" aria-hidden="true">⌛</div>
        <span class="sr-only">Loading…</span>
    </div>
    <div id="map">
    </div>
    <div id="controls">
        <div>
            <select id="timeSelect"></select>
            <button type="button" data-nav="time" data-direction="prev" aria-label="Previous time step">◀</button>
            <button type="button" data-nav="time" data-direction="next" aria-label="Next time step">▶</button>
        </div>
        <div>
            <select id="altitudeSelect"></select>
            <button type="button" data-nav="altitude" data-direction="prev" aria-label="Previous altitude level">◀</button>
            <button type="button" data-nav="altitude" data-direction="next" aria-label="Next altitude level">▶</button>
        </div>
    </div>
    <div class="center-marker">
        <div id="centerLabel" class="marker-label" role="status" aria-live="polite">Loading…<br>Loading…</div>
        <div class="marker-dot"></div>
    </div>
    <script type="module">
        const RELOAD_INTERVAL_MS = 3 * 60 * 60 * 1000;
        const DEFAULT_MODEL = 'CH1';
        const DEFAULT_MEMBER = 'CTRL';
        const DEFAULT_ALTITUDE_LEVEL = 'Z80';
        const ALTITUDE_START = 35;
        const ALTITUDE_END = 80;
        const FORECAST_HOURS = 34;
        const IMAGE_UNSCALE = [-128, 127];
        const DATA_BOUNDS = [5.379263587935693, 45.497280246347316, 11.0242973, 48.1058362];
        const CLIP_BOUNDS = [-5, 45, 12, 49];
        const BEFORE_LAYER_ID = 'water-lake';
        const WIND_PALETTE = [
            [1.852 * 0, [255, 255, 255]],
            [1.852 * 4, [239, 244, 209]],
            [1.852 * 6, [232, 244, 158]],
            [1.852 * 10, [170, 206, 99]],
            [1.852 * 14, [170, 206, 99]],
            [1.852 * 18, [226, 237, 22]],
            [1.852 * 22, [255, 237, 0]],
            [1.852 * 26, [255, 237, 130]],
            [1.852 * 30, [244, 209, 127]],
            [1.852 * 35, [237, 165, 73]],
            [1.852 * 40, [229, 140, 61]],
            [1.852 * 45, [219, 124, 61]],
        ];
        const PARTICLE_PALETTE = [
            [0, [0, 0, 0]],
            [15, [255, 255, 255]],
        ];
        const loadingOverlay = document.getElementById('loadingOverlay');

        const overlayLocks = new Set();
        const updateOverlayVisibility = () => {
            if (!loadingOverlay) {
                return;
            }
            if (overlayLocks.size > 0) {
                loadingOverlay.classList.remove('is-hidden');
            } else {
                loadingOverlay.classList.add('is-hidden');
            }
        };
        const requestOverlayLock = key => {
            if (!loadingOverlay) {
                return;
            }
            overlayLocks.add(key);
            updateOverlayVisibility();
        };
        const releaseOverlayLock = key => {
            if (!loadingOverlay) {
                return;
            }
            overlayLocks.delete(key);
            updateOverlayVisibility();
        };

        const INITIAL_OVERLAY_LOCK = 'initial-page-load';
        requestOverlayLock(INITIAL_OVERLAY_LOCK);
        const handleInitialLoadComplete = () => releaseOverlayLock(INITIAL_OVERLAY_LOCK);
        window.addEventListener('load', handleInitialLoadComplete, { once: true });
        if (document.readyState === 'complete') {
            handleInitialLoadComplete();
        }
        
        const buildForecastUrl = (model, member, altitude, time) =>
            `data-copy/${model}-${member}-${altitude}-${time}-wind.png`;
        const buildHeightUrl = altitude => `data-copy/hfl-${altitude}.tif`;
        const computeParticleCount = () => Math.max(1, Math.round((window.innerWidth * window.innerHeight) / 3000));

        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const reloadTimer = window.setTimeout(() => window.location.reload(), RELOAD_INTERVAL_MS);
                window.addEventListener('beforeunload', () => window.clearTimeout(reloadTimer));

                WeatherLayers.setLibrary('geotiff', GeoTIFF);

                const centerLabel = document.getElementById('centerLabel');
                const selects = {
                    time: document.getElementById('timeSelect'),
                    altitude: document.getElementById('altitudeSelect'),
                };
                const navButtons = Array.from(document.querySelectorAll('[data-nav]'));

                const protocol = new pmtiles.Protocol();
                maplibregl.addProtocol('pmtiles', protocol.tile);

                const map = window.map = new maplibregl.Map({
                    container: 'map',
                    style: 'style-white.json',
                    center: [8.2, 46.8],
                    zoom: 8,
                    hash: 'map',
                    attributionControl: false,
                });

                map.once('load', () => {
                    map.addSource('dem', {
                        type: 'raster-dem',
                        tiles: ['https://elevation-tiles-prod.s3.amazonaws.com/terrarium/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        minzoom: 0,
                        maxzoom: 13,
                        encoding: 'terrarium',
                    });
                    map.addLayer({
                        id: 'hills',
                        type: 'hillshade',
                        source: 'dem',
                        paint: {
                            'hillshade-method': 'igor',
                            'hillshade-illumination-altitude': 45,
                            'hillshade-illumination-direction': 315,
                            'hillshade-shadow-color': 'rgba(0, 0, 0, 0.3)',
                            'hillshade-highlight-color': 'rgba(255, 255, 255, 0.3)',
                            'hillshade-accent-color': 'rgba(0, 0, 0, 0.3)',
                        },
                    }, 'places_locality');
                });

                const attributionHtml = [
                    '<a href="https://sma.ch">MeteoSwiss ICON CH1</a>',
                    '<a href="https://weatherlayers.com/">WeatherLayers</a>',
                    '<a href="https://github.com/dducret/lowlevelwind">Source Code</a>',
                ].join(' | ');
                map.addControl(new maplibregl.AttributionControl({
                    compact: true,
                    customAttribution: attributionHtml,
                }), 'top-left');

                await new Promise(resolve => map.once('style.load', resolve));

                const deckLayer = new deck.MapboxOverlay({
                    interleaved: true,
                    layers: [],
                });
                map.addControl(deckLayer);

                function waitForDeck(getDeck) {
                    return new Promise(resolve => {
                        function poll() {
                            const deckInstance = getDeck();
                            if (deckInstance && deckInstance.getCanvas()) {
                                resolve(deckInstance);
                            } else {
                                setTimeout(poll, 100);
                            }
                        }
                        poll();
                    });
                }

                await waitForDeck(() => deckLayer._deck);

                const clipExtension = new deck.ClipExtension();
                const baseLayerProps = {
                    image2: null,
                    imageSmoothing: 0,
                    imageInterpolation: WeatherLayers.ImageInterpolation.CUBIC,
                    imageWeight: 0,
                    bounds: DATA_BOUNDS,
                    visible: true,
                    extensions: [clipExtension],
                    clipBounds: CLIP_BOUNDS,
                    beforeId: BEFORE_LAYER_ID,
                };

                let image;
                let hflImage;
                let hasLayerData = false;
                let latestUpdateToken = 0;

                const updateMarkerLabel = () => {
                    if (!hasLayerData) {
                        return;
                    }
                    if (!image || !hflImage) {
                        centerLabel.innerHTML = 'NaN km/h<br>NaN m AMSL';
                        return;
                    }

                    try {
                        const center = map.getCenter();
                        const mapBounds = map.getBounds();
                        const sampleLat = (center.lat + mapBounds.getNorth()) / 2;
                        const samplePoint = [[center.lng, sampleLat]];

                        const windCollection = WeatherLayers.getRasterPoints({
                            image,
                            image2: null,
                            imageSmoothing: 0,
                            imageInterpolation: WeatherLayers.ImageInterpolation.CUBIC,
                            imageWeight: 0,
                            imageType: WeatherLayers.ImageType.VECTOR,
                            imageUnscale: IMAGE_UNSCALE,
                        }, DATA_BOUNDS, samplePoint);

                        const windValue = windCollection?.features?.[0]?.properties?.value;

                        const heightCollection = WeatherLayers.getRasterPoints({
                            image: hflImage,
                            image2: null,
                            imageSmoothing: 0,
                            imageInterpolation: WeatherLayers.ImageInterpolation.CUBIC,
                            imageWeight: 0,
                            imageType: WeatherLayers.ImageType.SCALAR,
                        }, DATA_BOUNDS, samplePoint);

                        const elevationValue = heightCollection?.features?.[0]?.properties?.value;

                        if (typeof windValue === 'number' && typeof elevationValue === 'number') {
                            centerLabel.innerHTML = `${windValue.toFixed(1)} km/h<br>${elevationValue.toFixed(0)} m AMSL`;
                        } else {
                            centerLabel.innerHTML = 'NaN km/h<br>NaN m AMSL';
                        }
                    } catch (error) {
                        console.warn('Unable to update marker label', error);
                        centerLabel.innerHTML = 'NaN km/h<br>NaN m AMSL';
                    }
                };

                const requestMarkerUpdate = (() => {
                    let scheduled = false;
                    return () => {
                        if (scheduled) {
                            return;
                        }
                        scheduled = true;
                        requestAnimationFrame(() => {
                            scheduled = false;
                            updateMarkerLabel();
                        });
                    };
                })();

                const setEmptyLayers = () => {
                    hasLayerData = false;
                    deckLayer.setProps({ layers: [] });
                    centerLabel.innerHTML = 'NaN km/h<br>NaN m AMSL';
                    requestMarkerUpdate();
                };

                const buildLayers = () => [
                    new WeatherLayers.RasterLayer({
                        ...baseLayerProps,
                        id: 'raster',
                        image,
                        imageType: WeatherLayers.ImageType.VECTOR,
                        imageUnscale: IMAGE_UNSCALE,
                        palette: WIND_PALETTE,
                        opacity: 1.0,
                        pickable: true,
                    }),
                    new WeatherLayers.ParticleLayer({
                        ...baseLayerProps,
                        id: 'particle',
                        image,
                        imageType: WeatherLayers.ImageType.VECTOR,
                        imageUnscale: IMAGE_UNSCALE,
                        palette: PARTICLE_PALETTE,
                        opacity: 1.0,
                        animate: true,
                        numParticles: computeParticleCount(),
                        maxAge: 15,
                        speedFactor: 8,
                        width: 2.5,
                        color: [255, 255, 255],
                        getPolygonOffset: () => [0, -1000],
                    }),
                ];

                const applyLayers = () => {
                    if (!image || !hflImage) {
                        setEmptyLayers();
                        return;
                    }
                    hasLayerData = true;
                    deckLayer.setProps({ layers: buildLayers() });
                    requestMarkerUpdate();
                };

                const requestLayerRefresh = (() => {
                    let scheduled = false;
                    return () => {
                        if (scheduled || !image || !hflImage) {
                            return;
                        }
                        scheduled = true;
                        requestAnimationFrame(() => {
                            scheduled = false;
                            applyLayers();
                        });
                    };
                })();

                const updateLayers = async (model, member, altitude, time) => {
                    const token = ++latestUpdateToken;
                    const overlayKey = `layer-update-${token}`;
                    requestOverlayLock(overlayKey);
                    let textures;
                    try {
                        textures = await Promise.all([
                            WeatherLayers.loadTextureData(buildForecastUrl(model, member, altitude, time), false),
                            WeatherLayers.loadTextureData(buildHeightUrl(altitude), false),
                        ]);
                    } catch (error) {
                        if (token === latestUpdateToken) {
                            console.error('Failed to load weather layers', error);
                            image = undefined;
                            hflImage = undefined;
                            setEmptyLayers();
                        }
                        releaseOverlayLock(overlayKey);
                        return;
                    }

                    if (token !== latestUpdateToken) {
                        releaseOverlayLock(overlayKey);
                        return;
                    }

                    try {
                        [image, hflImage] = textures;
                        applyLayers();
                    } finally {
                        releaseOverlayLock(overlayKey);
                    }
                };

                window.addEventListener('resize', requestLayerRefresh);

                const updateNavButtonState = () => {
                    navButtons.forEach(button => {
                        const { nav, direction } = button.dataset;
                        const select = selects[nav];
                        if (!select) {
                            return;
                        }
                        if (direction === 'prev') {
                            button.disabled = select.selectedIndex <= 0;
                        } else if (direction === 'next') {
                            button.disabled = select.selectedIndex >= select.options.length - 1;
                        }
                    });
                };

                navButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const { nav, direction } = button.dataset;
                        const select = selects[nav];
                        if (!select || (direction !== 'next' && direction !== 'prev')) {
                            return;
                        }
                        const delta = direction === 'next' ? 1 : -1;
                        const newIndex = Math.min(Math.max(select.selectedIndex + delta, 0), select.options.length - 1);
                        if (newIndex !== select.selectedIndex) {
                            select.selectedIndex = newIndex;
                            select.dispatchEvent(new Event('change'));
                        }
                    });
                });

                map.on('move', requestMarkerUpdate);
                map.dragRotate.disable();
                map.touchZoomRotate.disableRotation();
                map.keyboard.disableRotation();
                map.setPitch(0);
                map.setBearing(0);
                map.resize();
                map.once('idle', requestMarkerUpdate);

                async function loadAltitudeLabels() {
                    try {
                        const response = await fetch('altitude_levels.json');
                        if (!response.ok) {
                            throw new Error(`Unexpected response ${response.status}`);
                        }
                        const payload = await response.json();
                        if (Array.isArray(payload)) {
                            return payload.reduce((acc, entry) => {
                                if (!entry) {
                                    return acc;
                                }
                                const code = entry.code ?? entry.id ?? entry.level ?? entry.name;
                                const value = entry.meters ?? entry.altitude ?? entry.height ?? entry.value ?? entry.label;
                                if (code !== undefined) {
                                    acc[String(code)] = value;
                                }
                                return acc;
                            }, {});
                        }
                        if (payload && typeof payload === 'object') {
                            if (payload.levels && typeof payload.levels === 'object') {
                                return payload.levels;
                            }
                            return payload;
                        }
                    } catch (error) {
                        console.warn('Unable to load altitude label mapping, falling back to model level codes.', error);
                    }
                    return {};
                }

                const altitudeLabelPromise = loadAltitudeLabels();
                const lastRunResponse = await fetch('data-copy/last_run.json');
                if (!lastRunResponse.ok) {
                    throw new Error(`Unexpected response ${lastRunResponse.status} while loading available times.`);
                }
                const data = await lastRunResponse.json();
                const lastRunTimestamp = Number(data.last_run);
                if (!Number.isFinite(lastRunTimestamp)) {
                    throw new Error('Received invalid last_run timestamp.');
                }

                const altitudeLabelMap = await altitudeLabelPromise;

                const times = Array.from({ length: FORECAST_HOURS }, (_, index) => lastRunTimestamp + index * 3600);
                const altitudeSteps = Array.from({ length: ALTITUDE_END - ALTITUDE_START + 1 }, (_, index) => `Z${ALTITUDE_START + index}`);

                const dayFormatter = new Intl.DateTimeFormat([], { weekday: 'long' });
                const timeFormatter = new Intl.DateTimeFormat([], { hour: '2-digit', minute: '2-digit', hourCycle: 'h23' });

                const formatTimeLabel = value => {
                    const date = new Date(Number(value) * 1000);
                    return `${dayFormatter.format(date)} ${timeFormatter.format(date)}`;
                };

                const formatAltitudeLabel = code => {
                    const raw = altitudeLabelMap?.[code];
                    if (raw === undefined || raw === null) {
                        return code;
                    }
                    if (typeof raw === 'number' && Number.isFinite(raw)) {
                        return `${raw} m AGL`;
                    }
                    const trimmed = String(raw).trim();
                    if (trimmed === '') {
                        return code;
                    }
                    if (/\b(agl|amsl)\b/i.test(trimmed) || /m\b/i.test(trimmed)) {
                        return trimmed;
                    }
                    const numeric = Number(trimmed);
                    if (!Number.isNaN(numeric)) {
                        return `${numeric} m AGL`;
                    }
                    return `${trimmed} m AGL`;
                };

                const populateSelect = (select, values, { formatter, defaultValue, onOption } = {}) => {
                    const fragment = document.createDocumentFragment();
                    values.forEach(value => {
                        const option = document.createElement('option');
                        option.value = String(value);
                        const label = formatter ? formatter(value) : value;
                        option.textContent = label;
                        if (onOption) {
                            onOption(option, value, label);
                        }
                        fragment.appendChild(option);
                    });
                    select.replaceChildren(fragment);
                    if (defaultValue !== undefined) {
                        select.value = String(defaultValue);
                    }
                };

                populateSelect(selects.time, times, { formatter: formatTimeLabel });
                populateSelect(selects.altitude, altitudeSteps, {
                    formatter: formatAltitudeLabel,
                    defaultValue: DEFAULT_ALTITUDE_LEVEL,
                    onOption(option, value, label) {
                        if (label !== value) {
                            option.title = `${value} (${label})`;
                        }
                    },
                });

                const handleSelectionChange = () => {
                    updateNavButtonState();
                    const altitude = selects.altitude.value;
                    const time = selects.time.value;
                    updateLayers(DEFAULT_MODEL, DEFAULT_MEMBER, altitude, time);
                };

                selects.time.addEventListener('change', handleSelectionChange);
                selects.altitude.addEventListener('change', handleSelectionChange);

                handleSelectionChange();
            } catch (error) {
                console.error('Failed to initialise application', error);
            }
        });
    </script>
</body>

</html>
